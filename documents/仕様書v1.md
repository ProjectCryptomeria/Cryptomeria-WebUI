## 📑 RaidChain WebUI 仕様書 (v1.0)

---

### 1. イントロダクション（序論）

- **1.1. 目的とスコープ**
  - **目的**: 従来のCLI/Shellスクリプトによる煩雑な操作を、TypeScript/Reactを用いたGUI操作に完全に置き換え、RaidChainの研究開発および運用効率を最大化する。
  - **スコープ**: Ignite buildで生成されたバイナリを用いた後の全ての操作（Dockerビルド、k8sデプロイ、アカウント管理、実験実行、モニタリング）をGUIで提供する。
- **1.2. 背景と課題**
  - **従来の課題**: 複雑な実験シナリオの作成がJustfileの「魔改造」に依存していた。k8s Jobを用いたニーモニック・ジェネシスブロックの管理やDatachainの柔軟なスケーリングが煩雑であった。
  - **WebUIによる解決**: 直感的なGUI操作と、APIサーバーによるKubernetes操作の抽象化、およびアカウントDB管理により、これらの課題を解消する。
- **1.3. 究極の目的とビジョン**
  - Cosmosエコシステムを使った**モジュラーブロックチェーン** + **分散ストレージ＆Webホスティングシステム**を、手軽に操作し、研究開発するための統合WebUI。
- **1.4. 用語の定義**
  - **RaidChain**: Cosmos SDKベースでInternet ComputerのようなフルオンチェーンWebを目指すシステム。
  - **Datachain**: データ保存用の負荷分散ノード（可変個数）。
  - **Metachain**: メタデータ保存ノード。
  - **Controlchain**: システム統合管理ノード。
  - **k8s**: Kubernetes（抽象化されたオーケストレーション環境）。
  - **IBC**: Inter-Blockchain Communication。

---

### 2. システムアーキテクチャと依存関係

- **2.1. RaidChain システム構成**
  - **Datachain**（データ保存）、**Metachain**（メタデータ）、**Controlchain**（ロジック・統合管理）、**Relayer**（IBC通信）の4種類のチェーンで構成されるモジュラー型システム。
- **2.2. WebUIを含む全体アーキテクチャ**
  - **フロントエンド** (React/TS) から **WebUI APIサーバー** (未実装) を経由して、**k8sクラスタ** (RaidChainノード群) および **アカウント管理DB** (APIサーバーからアクセス可能なDB) へ接続する。
  - ノードモニタリングおよびビルドログには**WebSocket通信**を使用する。
- **2.3. 技術スタック**
  - **フロントエンド**: **TypeScript**, **React**, **Zustand** (状態管理), **Tailwind CSS**, Vite。
  - **モック環境**: **MSW (Mock Service Worker)**。
  - **インフラ**: **Kubernetes**, **Docker**, **Helm**。
  - **API/コントローラ**: 従来の環境からTypeScriptコントローラーが存在。APIサーバーはGoまたはNode.js(TS)を想定。
- **2.4. CLI操作の代替・吸収範囲**
  - **Dockerイメージの作成**。
  - **k8s Jobによるニーモニック・ジェネシスブロック作成**。
  - **Helm ChartのInstall/Upgrade/Delete**によるデプロイ・スケーリング。
  - **TypeScriptを用いたオフチェーンコントローラー**による実験実行ロジック。

---

### 3. 機能要件（フロントエンド / WebUI）

- **3.1. ネットワークモニタリング**
  - ネットワーク**トポロジー（SVG）**によるノード配置の可視化。
  - ノードの**ブロック高**、**レイテンシ**、ステータスのリアルタイム表示。
  - **Mempoolのグラフ**表示。
  - **Base Fee**（基本手数料）の変動監視。
- **3.2. デプロイメント・オペレーション**
  - Target Componentを選択したDockerイメージビルドの実行と`LogViewer`による**リアルタイムログストリーミング**。
  - Datachainのレプリカ数を**スライダー**で設定し、**スケーリング**（Helm Upgrade）を実行。
  - 確認付きの環境リセット機能。
- **3.3. アカウント/経済圏管理**
  - ユーザーアカウントの**作成/削除**。
  - **Faucet**実行（1000 TKN供給）。
  - 秘密鍵/ニーモニックの**安全な表示**。
  - リレーヤーの残高不足を監視し、自動でFaucetを実行する**Watchdog機能**のON/OFF。
- **3.4. 実験シナリオ作成・実行**
  - **データソース**: 仮想データ生成、またはZip/ファイルアップロード（`FileTreeViewer`表示）。
  - **パラメータ**: データサイズ/チャンクサイズ/チェーン数の**範囲（Range）設定**による多重シナリオ生成。
  - **戦略**: Allocator/Transmitterの組み合わせ選択。
  - **実行管理**: 試算コスト自動計算、シナリオの一括生成と一括実行、リアルタイム実行進捗の表/ログ表示。
- **3.5. 実験結果ライブラリ**
  - 過去の実験結果（`ExperimentResult`）の一覧表示。
  - 検索、ソート、フィルタリング機能。
  - 結果の詳細（パラメータ、実行時間、スループット）の確認。
  - **CSV/JSON形式**でのデータエクスポート。
- **3.6. プリセット管理**
  - 現在設定されている実験設定をプリセットとして保存し、後でロードして再利用する機能。
  - 保存済みプリセットの編集・削除。

---

### 4. 機能要件（バックエンド / API）

- **4.1. チェーン制御API**
  - k8s APIを介したDockerビルドコマンドの実行とログの取得。
  - Helmのラッパーとして機能し、Datachainのレプリカ数変更要求（スケーリング）を処理。
- **4.2. アカウント/鍵管理API**
  - ニーモニックの生成・検証と、**WebUI/APIからアクセス可能なDB**への**暗号化保存**。
  - ジェネシスアカウントの作成とチェーンへの登録処理を抽象化。
- **4.3. 実験実行コントローラー**
  - 従来の**オフチェーンコントローラー**の移植。
  - シナリオに基づき、**チャンク分割**、Allocator/Transmitter戦略の適用、ブロックチェーンへのトランザクション送信、実行中のメトリクス計測を行う。
- **4.4. データ永続化API**
  - 実験シナリオ定義、生成されたシナリオ、および詳細な実験結果（メトリクス）を永続的に保存し、フロントエンドからの要求に応じて提供する。
- **4.5. リアルタイム通信API**
  - **WebSocket**を用いた通信チャネルを確立。
  - モニタリングデータ（ノード状態）、デプロイログストリーム、実験実行ログをフロントエンドに継続的にプッシュ配信する。

---

### 5. 非機能要件

- **5.1. 性能要件**
  - **モニタリングデータ**は最低1秒単位で更新されること。
  - Datachainの**スケーリング**は可能な限り迅速（例: 10秒以内）に完了すること。
  - 実験コントローラーは従来のCLIスクリプトと同等以上のスループットを維持すること。
- **5.2. セキュリティ要件**
  - WebUIとAPIサーバー間の通信は**HTTPS/WSS**を適用。
  - ニーモニック/秘密鍵はAPIサーバーのDBで**AES-256などの方式で暗号化**して管理すること。
  - APIは適切な認証・認可機構（例: JWT）を導入すること。
- **5.3. ユーザビリティ要件**
  - 全画面で**モダンで統一されたデザイン**（Tailwind CSSベース）を適用すること。
  - 複雑なフォーム（実験設定）は直感的で、入力検証フィードバックを提供すること。
  - `BottomPanel`など、開発者向けの機能は柔軟な操作性（リサイズ）を提供すること。
- **5.4. 信頼性・可用性**
  - k8sクラスタやRaidChainノードとの接続障害発生時に、ユーザーに適切な**通知（Notification）**を行うこと。
  - 実験実行中のトランザクション失敗時やコントローラー異常終了時に、ログを保存し、リトライまたはクリーンアップのオプションを提供すること。

---

### 6. 技術設計（詳細）

- **6.1. データモデル定義**
  - **主要エンティティ**: `Account`, `Node`, `Scenario`, `ExperimentResult`, `Preset`のデータ構造を定義。
  - フロントエンドでは**TypeScriptの型**を厳密に定義し、フォーム検証には**Zod**などのスキーマ検証ライブラリを導入する。
- **6.2. フロントエンド設計**
  - **アーキテクチャ**: Atomic DesignまたはFeature Sliced Designに近い構造を採用（`pages`, `features`, `entities`）。
  - **状態管理**: **Zustand**をグローバルストアとして採用。
  - **UI**: カスタムコンポーネントを`shared/ui`配下に集約。
- **6.3. APIインターフェース設計**
  - **通信プロトコル**: RESTful API + WebSocket。
  - **エンドポイント例**: `POST /api/v1/deploy/build` (ビルド開始)、`PATCH /api/v1/deployment/scale` (スケーリング)、`POST /api/v1/economy/faucet` (資金供給)。

---

### 7. 開発・テスト・運用体制

- **7.1. 開発環境構築手順**
  - Node.js, Yarn PnP必須。`yarn install`後、`yarn dev`でVite開発サーバーを起動。
  - フロントエンド開発時には**MSW**を有効化し、モックAPIを介してバックエンド不在でもフル機能のテストを可能にする。
- **7.2. テスト戦略**
  - React Testing LibraryやJestを用いたコンポーネントテストおよびユニットテスト。
  - MSWを活用し、フロントエンドとモックAPI間の連携を含むE2Eテストを実行する。
- **7.3. デプロイメント手順**
  - CI/CDパイプラインを構築し、Dockerイメージのビルド、レジストリへのPush、Helm Chartを用いたk8sクラスタへのデプロイ・更新を自動化する。
